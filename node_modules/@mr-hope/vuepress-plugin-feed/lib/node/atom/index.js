"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderAtom = void 0;
const xml_js_1 = require("xml-js");
const utils_1 = require("../utils");
const genAuthororContributor = (author) => {
    const { name = "Unknown", email, url } = author;
    return {
        name,
        ...(email ? { email } : {}),
        ...(url ? { uri: (0, utils_1.encodeXML)(url) } : {}),
    };
};
const genCategory = (category) => {
    const { name, scheme = "" } = category;
    return {
        _attributes: {
            term: name,
            scheme,
        },
    };
};
/**
 * Returns an Atom 1.0 feed
 *
 * @see http://www.atomenabled.org/developers/syndication/
 */
const renderAtom = (feed) => {
    const { channel, links } = feed.options;
    const content = {
        _declaration: {
            _attributes: {
                version: "1.0",
                encoding: "utf-8",
            },
        },
        feed: {
            _attributes: {
                xmlns: "http://www.w3.org/2005/Atom",
                // eslint-disable-next-line @typescript-eslint/naming-convention
                ...(channel.language ? { "xml:lang": channel.language } : {}),
            },
            id: channel.link,
            title: channel.title,
            ...(channel.description ? { subtitle: channel.description } : {}),
            ...(channel.author
                ? { author: genAuthororContributor(channel.author) }
                : {}),
            updated: channel.lastUpdated
                ? channel.lastUpdated.toISOString()
                : new Date().toISOString(),
            generator: utils_1.FEED_GENERATOR,
            link: [{ _attributes: { rel: "self", href: (0, utils_1.encodeXML)(links.atom) } }],
        },
    };
    if (channel.link)
        content.feed.link.push({
            _attributes: { rel: "alternate", href: (0, utils_1.encodeXML)(channel.link) },
        });
    if (channel.hub)
        content.feed.link.push({
            _attributes: { rel: "hub", href: (0, utils_1.encodeXML)(channel.hub) },
        });
    if (channel.image)
        content.feed.logo = channel.image;
    if (channel.icon)
        content.feed.icon = channel.icon;
    if (channel.copyright)
        content.feed.rights = channel.copyright;
    content.feed.category = Array.from(feed.categories).map((category) => ({
        _attributes: { term: category },
    }));
    content.feed.contributor = Array.from(feed.contributors)
        .filter((contributor) => contributor.name)
        .map((contributor) => genAuthororContributor(contributor));
    /**
     * "entry" nodes
     */
    content.feed.entry = feed.items.map((item) => {
        // entry: required elements
        const entry = {
            title: { _attributes: { type: "html" }, _text: (0, utils_1.encodeXML)(item.title) },
            id: (0, utils_1.encodeXML)(item.guid || item.link),
            link: { _attributes: { href: (0, utils_1.encodeXML)(item.link) } },
            updated: item.lastUpdated.toISOString(),
        };
        // entry: recommended elements
        if (item.description) {
            entry.summary = item.description.startsWith("html:")
                ? {
                    _attributes: { type: "html" },
                    _cdata: (0, utils_1.encodeCDATA)(item.description.substring(5)),
                }
                : {
                    _attributes: { type: "html" },
                    _text: item.description,
                };
        }
        if (item.content)
            entry.content = {
                _attributes: { type: "html" },
                _cdata: (0, utils_1.encodeCDATA)(item.content),
            };
        // author(s)
        if (item.author)
            entry.author = item.author
                .filter((author) => author.name)
                .map((author) => genAuthororContributor(author));
        if (item.category)
            // category
            entry.category = item.category.map((category) => genCategory(category));
        // contributor
        if (item.contributor)
            entry.contributor = item.contributor.map((contributor) => genAuthororContributor(contributor));
        // published
        if (item.pubDate)
            entry.published = item.pubDate.toISOString();
        // rights
        if (item.copyright)
            entry.rights = item.copyright;
        return entry;
    });
    return (0, xml_js_1.js2xml)(content, {
        compact: true,
        ignoreComment: true,
        spaces: 2,
    });
};
exports.renderAtom = renderAtom;
//# sourceMappingURL=index.js.map