"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.md2text = exports.stripTags = exports.resolveUrl = exports.getImages = exports.getCover = exports.getDate = exports.getAuthor = exports.timeTransformer = exports.getLocales = exports.isAbsoluteUrl = exports.isUrl = void 0;
const dayjs_1 = require("./dayjs");
/**
 * check if string is a valid url
 */
const isUrl = (test) => {
    if (typeof test !== "string" || test === "")
        return false;
    // url Math
    const result = /^(?:\w+:)?\/\/(\S+)$/u.exec(test);
    if (!result)
        return false;
    const address = result[1];
    if (!address)
        return false;
    return (
    // address with localhost
    /^localhost[:?\d]*(?:[^:?\d]\S*)?$/u.test(address) ||
        // address without localhost
        /^[^\s.]+\.\S{2,}$/u.test(address));
};
exports.isUrl = isUrl;
const isAbsoluteUrl = (test) => test.startsWith("/");
exports.isAbsoluteUrl = isAbsoluteUrl;
const getLocales = (lang, locales) => Object.entries(locales)
    .map(([, value]) => value.lang)
    .filter((item) => typeof item === "string" && item !== lang);
exports.getLocales = getLocales;
const getLang = (lang = "en") => {
    const langcode = lang.toLowerCase();
    if (langcode === "zh" || langcode === "zh-cn")
        return "zh";
    if (langcode === "en-us" || langcode === "en-uk" || langcode === "en")
        return "en";
    console.warn(`${lang} locale missing in config`);
    return "en";
};
const timeTransformer = (date, options = {}) => {
    const { lang, timezone, type } = options;
    dayjs_1.dayjs.locale(getLang(lang));
    const dateText = timezone
        ? (0, dayjs_1.dayjs)(date).tz(timezone).format("LL")
        : (0, dayjs_1.dayjs)(date).format("LL");
    const timeText = timezone
        ? (0, dayjs_1.dayjs)(date).tz(timezone).format("HH:mm")
        : (0, dayjs_1.dayjs)(date).format("HH:mm");
    return type === "date"
        ? dateText
        : type === "time"
            ? timeText
            : `${dateText} ${timeText}`;
};
exports.timeTransformer = timeTransformer;
const getAuthor = (author, canDisable = false) => {
    if (author) {
        if (Array.isArray(author)) {
            return author.map((item) => typeof item === "string" ? { name: item } : item);
        }
        if (typeof author === "string")
            return [{ name: author }];
        if (typeof author === "object" && author.name)
            return [author];
        console.error(`Expect 'author' to be \`AuthorInfo[] | AuthorInfo | string[] | string ${canDisable ? "" : "| false"} | undefined\`, but got`, author);
        return [];
    }
    return [];
};
exports.getAuthor = getAuthor;
const getDate = (date, options = {}) => {
    const { timezone } = options;
    if (date) {
        const time = (0, dayjs_1.dayjs)(date instanceof Date ? date : date.trim());
        if (time.isValid()) {
            const currentTime = timezone ? (0, dayjs_1.dayjs)(date).tz(timezone) : (0, dayjs_1.dayjs)(date);
            const year = currentTime.year();
            const month = currentTime.month() + 1;
            const day = currentTime.date();
            const hour = currentTime.hour();
            const minute = currentTime.minute();
            const second = currentTime.second();
            const millisecond = currentTime.millisecond();
            const isDate = hour === 0 && minute === 0 && second === 0 && millisecond === 0;
            const value = currentTime.toDate();
            return {
                display: (0, exports.timeTransformer)(value, {
                    type: isDate ? "date" : "full",
                    ...options,
                }),
                value,
                detail: {
                    year,
                    month,
                    day,
                    ...(isDate ? {} : { hour, minute, second }),
                },
            };
        }
        const timeRegPattern = /(?:(\d{2,4})[/-](\d{1,2})[/-](\d{1,2}))?\s*(?:(\d{1,2}):(\d{1,2})(?::(\d{1,2}))?)?/u;
        const result = timeRegPattern.exec(date.trim());
        if (result) {
            const [, year, month, day, hour, minute, second] = result;
            const getNumber = (a) => typeof a === "undefined" ? undefined : Number(a);
            const getYear = (yearNumber) => yearNumber && yearNumber < 100 ? yearNumber + 2000 : yearNumber;
            const getSecond = (secondNumber) => (hour && minute && !second ? 0 : secondNumber);
            const detail = {
                year: getYear(getNumber(year)),
                month: getNumber(month),
                day: getNumber(day),
                hour: getNumber(hour),
                minute: getNumber(minute),
                second: getSecond(getNumber(second)),
            };
            const isTime = year === undefined && month === undefined && day === undefined;
            const isDate = hour === undefined && minute === undefined && second === undefined;
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            const value = (0, dayjs_1.dayjs)({ ...detail, month: detail.month - 1 }).toDate();
            return {
                display: (0, exports.timeTransformer)(value, {
                    type: isDate ? "date" : isTime ? "time" : "full",
                    ...options,
                }),
                value: isTime ? undefined : value,
                detail: isDate
                    ? { year: detail.year, month: detail.month, day: detail.day }
                    : isTime
                        ? { hour: detail.hour, minute: detail.minute, second: detail.second }
                        : detail,
            };
        }
    }
    return null;
};
exports.getDate = getDate;
const getCover = (page, { hostname }, { base }) => {
    const banner = page.frontmatter["banner"];
    const cover = page.frontmatter["cover"];
    if (banner) {
        if ((0, exports.isAbsoluteUrl)(banner))
            return (0, exports.resolveUrl)(hostname, base, banner);
        if ((0, exports.isUrl)(banner))
            return banner;
    }
    if (cover) {
        if ((0, exports.isAbsoluteUrl)(cover))
            return (0, exports.resolveUrl)(hostname, base, cover);
        if ((0, exports.isUrl)(cover))
            return cover;
    }
    return null;
};
exports.getCover = getCover;
const getImages = (page, options, { base }) => {
    const result = /!\[.*?\]\((.*?)\)/giu.exec(page._content);
    if (result) {
        return result
            .map(([, link]) => {
            if ((0, exports.isAbsoluteUrl)(link))
                return (0, exports.resolveUrl)(options.hostname, base, link);
            if ((0, exports.isUrl)(link))
                return link;
            return null;
        })
            .filter((item) => item !== null);
    }
    return [];
};
exports.getImages = getImages;
const resolveUrl = (hostname, base, url) => `${hostname.match(/https?:\/\//) ? "" : "https://"}${hostname.replace(/\/$/, "")}${base}${url.replace(/^\//, "")}`;
exports.resolveUrl = resolveUrl;
const stripTags = (content = "") => content
    // remove html tags
    .replace(/<\/?.+?\/?>/g, "");
exports.stripTags = stripTags;
const md2text = (content) => content
    ? (0, exports.stripTags)(content)
        // remove img
        .replace(/!\[(.*?)\]\(.*?\)/gm, "")
        // remove code blocks
        .replace(/```([\s\S]*?)```/g, "")
        // remove custom container end
        .replace(/^\s*:::\s*$/gm, "")
        // remove custom container start
        .replace(/^\s*:::\s*(.+?)(?:\s+(.*))?$/gm, "$2")
        // remove heading1
        .replace(/^# (.*)$/gm, "$1")
        // convert other headings to text
        .replace(/^#{1,6} (.*)$/gm, "$1")
        // convert unordered lists to text with comma
        .replace(/^\s*[-*+] (.*)$/gm, "$1; ")
        // convert blockquotes with quotes
        .replace(/^\s*>+(.*)$/gm, '"$1"')
        // convert links to text
        .replace(/(^|[^\\])\[(.*?)\]\(.*?\)/gm, "$1$2")
        // convert inline code
        .replace(/`{1,2}([^`])(.*?)`{1,2}/g, "$1$2")
        // just remove delete lines
        .replace(/~~(.*?)~~/g, "")
        // remove bold or italic
        .replace(/(^|[^\\])([*|_]{1,2})(.*?)([^\\])\2/gm, "$1$3$4")
        // remove html tags
        .replace(/<\/?.+?\/?>/g, "")
        // trim lines
        .split("\n")
        .map((line) => line.trim())
        .join("\n")
        // covert link breaks into spaces
        .replace(/(?:\r?\n)+/g, " ")
        // covert 2 or more spaces into 1
        .replace(/ +/g, " ")
        // trim
        .trim()
    : "";
exports.md2text = md2text;
//# sourceMappingURL=utils.js.map