"use strict";
/**
 * 覆盖 inline rule, 包括
 *
 * - 对渲染标签增加属性
 * - 对文本进行替换
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.stylize = void 0;
const scanTokens = (tokens, options, skipContents = []) => {
    for (let index = 1, len = tokens.length; index < len - 1; index++) {
        const token = tokens[index];
        const { content, type } = token;
        // skip currect token
        if (type !== "text" || skipContents.includes(content))
            continue;
        const config = options.find(({ matcher }) => typeof matcher === "string" ? matcher === content : matcher.test(content));
        const tokenPrev = tokens[index - 1];
        const tokenNext = tokens[index + 1];
        if (config &&
            tokenPrev.tag === tokenNext.tag &&
            tokenPrev.nesting === 1 &&
            tokenNext.nesting === -1) {
            const result = config.replacer({
                tag: tokenPrev.tag,
                content: token.content,
                attrs: Object.fromEntries(tokenPrev.attrs || []),
            });
            if (result) {
                tokenPrev.tag = tokenNext.tag = result.tag;
                tokenPrev.attrs = Object.entries(result.attrs);
                token.content = result.content;
            }
            // skip 2 tokens
            index += 2;
        }
    }
};
const stylize = (md, options = []) => {
    if (Object.keys(options).length == 0)
        return;
    md.core.ruler.push("stylize_tag", ({ env, tokens }) => {
        const { noStylize } = env.frontmatter || {};
        tokens.forEach(({ type, children }) => {
            if (type === "inline")
                scanTokens(children || [], options, noStylize);
        });
        return true;
    });
};
exports.stylize = stylize;
//# sourceMappingURL=stylize.js.map