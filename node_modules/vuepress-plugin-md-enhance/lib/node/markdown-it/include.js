"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.include = exports.createIncludeCoreRule = exports.resolveInclude = exports.handleInclude = void 0;
const fs_1 = require("fs");
const upath_1 = require("upath");
const utils_1 = require("./utils");
// regexp to match the import syntax
const SYNTAX_RE = /^@include\(([^)]*?)(?:\{(\d+)?-(\d+)?\})?\)$/;
const handleInclude = ({ filePath, lineStart, lineEnd }, { cwd, includedFiles }) => {
    let realPath = filePath;
    if (!(0, upath_1.isAbsolute)(filePath)) {
        // if the importPath is relative path, we need to resolve it
        // according to the markdown filePath
        if (!cwd) {
            console.error(`Include: Error when resolving path: ${filePath}`);
            return "\nError when resolving path\n";
        }
        realPath = (0, upath_1.resolve)(cwd, filePath);
    }
    includedFiles.push(realPath);
    // check file existence
    if (!(0, fs_1.existsSync)(realPath)) {
        console.error(`Include: ${realPath} not found`);
        return "\nFile not found\n";
    }
    // read file content
    const fileContent = (0, fs_1.readFileSync)(realPath).toString();
    // return content
    return fileContent
        .replace(utils_1.NEWLINES_RE, "\n")
        .split("\n")
        .slice(lineStart ? lineStart - 1 : lineStart, lineEnd)
        .join("\n")
        .replace(/\n?$/, "\n");
};
exports.handleInclude = handleInclude;
const resolveInclude = (content, options, { cwd, includedFiles }) => content
    .split("\n")
    .map((line) => {
    if (line.startsWith("@include")) {
        // check if itâ€™s matched the syntax
        const match = line.match(SYNTAX_RE);
        if (match) {
            const [, includePath, lineStart, lineEnd] = match;
            const actualPath = options.getPath(includePath);
            const content = (0, exports.handleInclude)({
                filePath: actualPath,
                lineStart: lineStart ? Number.parseInt(lineStart, 10) : 0,
                lineEnd: lineEnd ? Number.parseInt(lineEnd, 10) : undefined,
            }, { cwd, includedFiles });
            return options.deep && actualPath.endsWith(".md")
                ? (0, exports.resolveInclude)(content, options, {
                    cwd: (0, upath_1.isAbsolute)(actualPath)
                        ? (0, upath_1.dirname)(actualPath)
                        : cwd
                            ? (0, upath_1.resolve)(cwd, (0, upath_1.dirname)(actualPath))
                            : null,
                    includedFiles,
                })
                : content;
        }
    }
    return line;
})
    .join("\n");
exports.resolveInclude = resolveInclude;
const createIncludeCoreRule = (options) => (state) => {
    const env = state.env;
    const includedFiles = env.includedFiles || (env.includedFiles = []);
    state.src = (0, exports.resolveInclude)(state.src, options, {
        cwd: env.filePath ? (0, upath_1.dirname)(env.filePath) : null,
        includedFiles,
    });
    return true;
};
exports.createIncludeCoreRule = createIncludeCoreRule;
const include = (md, { getPath = (path) => path, deep = false } = {}) => {
    // add md_import core rule
    md.core.ruler.after("normalize", "md_import", (0, exports.createIncludeCoreRule)({ getPath, deep }));
};
exports.include = include;
//# sourceMappingURL=include.js.map