export const options = CODE_DEMO_OPTIONS;
export const preProcessorConfig = {
    html: {
        types: ["html", "slim", "haml", "md", "markdown", "vue"],
        map: {
            html: "none",
            vue: "none",
            md: "markdown",
        },
    },
    js: {
        types: [
            "js",
            "javascript",
            "coffee",
            "coffeescript",
            "ts",
            "typescript",
            "ls",
            "livescript",
        ],
        map: {
            js: "none",
            javascript: "none",
            coffee: "coffeescript",
            ls: "livescript",
            ts: "typescript",
        },
    },
    css: {
        types: ["css", "less", "sass", "scss", "stylus", "styl"],
        map: {
            css: "none",
            styl: "stylus",
        },
    },
};
export const h = (tag, attrs, children) => {
    const node = document.createElement(tag);
    attrs &&
        Object.keys(attrs).forEach((key) => {
            if (!key.indexOf("data")) {
                const k = key.replace("data", "");
                node.dataset[k] = attrs[key];
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
            }
            else
                node[key] = attrs[key];
        });
    if (children)
        children.forEach((child) => {
            node.appendChild(child);
        });
    return node;
};
export const getConfig = (config) => ({
    ...options,
    ...config,
    jsLib: Array.from(new Set([...(options.jsLib || []), ...(config.jsLib || [])])),
    cssLib: Array.from(new Set([...(options.cssLib || []), ...(config.cssLib || [])])),
});
export const loadScript = (state, link) => {
    if (state[link] !== undefined)
        return state[link];
    const loadEvent = new Promise((resolve) => {
        var _a;
        const script = document.createElement("script");
        script.src = link;
        (_a = document.querySelector("body")) === null || _a === void 0 ? void 0 : _a.appendChild(script);
        script.onload = () => {
            resolve();
        };
    });
    state[link] = loadEvent;
    return loadEvent;
};
export const injectCSS = (shadowRoot, code) => {
    if (code.css &&
        // style not injected
        Array.from(shadowRoot.childNodes).every((element) => element.nodeName !== "STYLE")) {
        const style = h("style", { innerHTML: code.css });
        shadowRoot.appendChild(style);
    }
};
export const injectScript = (id, shadowRoot, code) => {
    const scriptText = code.getScript();
    if (scriptText &&
        // style not injected
        Array.from(shadowRoot.childNodes).every((element) => element.nodeName !== "SCRIPT")) {
        const script = document.createElement("script");
        script.appendChild(document.createTextNode(
        // here we are fixing `document` variable back to shadowDOM
        `{const document=window.document.querySelector('#${id} .code-demo-container').shadowRoot;\n${scriptText}}`));
        shadowRoot.appendChild(script);
    }
};
//# sourceMappingURL=utils.js.map